import { readdir } from 'fs';
import { promisify } from 'util';

import * as core from '@actions/core';
import { LokaliseApi } from '@lokalise/node-api';

import { loadTranslationFile, Message } from '@src/loader/loader';
import { LOKALISE_DEVICE_PLATFORM, LokaliseListKeysPayload } from '../types';

const LOKALISE_FETCH_LIMIT = 5000;

// The placeholder that Lokalise supports and expects
const LANG_ISO_PLACEHOLDER = '%LANG_ISO%';

/**
 * Base wrapper around the Lokalise Node API.
 * https://lokalise.github.io/node-lokalise-api/
 *
 * Lokalise uses the concept of keys {@link LokaliseKey} to organize translation messages.
 * Locally translation message organization is based on framework and libraries.
 */
export class LokaliseClient {
  lokaliseApi: LokaliseApi;
  apiKey: string;
  projectId: string;
  languageISOCodeMapping: Record<string, string>;
  sourceLanguage: string;
  sourceLanguageDirectory: string;
  translationDirectory: string;
  format: string;
  platform: LOKALISE_DEVICE_PLATFORM;

  constructor(args: Record<string, string>) {
    Object.assign(this, args);
    this.languageISOCodeMapping = JSON.parse(args.languageISOCodeMapping);
    this.lokaliseApi = new LokaliseApi({ apiKey: args.apiKey });
  }

  /**
   * Builds an list of all translation messages based on this.directory
   *
   * Assumes:
   * 1) Unconventional PO files where:
   *  a) msgids are not the source string, but instead pseudo IDs.
   *  b) there is a message catalog for english strings.
   * 2) JSON files managed with @formatjs/cli
   *  a) using autogenerated message IDs and the Lokalise formatter.
   */
  async getLocalKeys(): Promise<Message[]> {
    const localKeys = [];

    try {
      const filePath = this.getLanguageFilePath(this.sourceLanguage);
      const fileNames = await promisify(readdir)(filePath);

      for (const fileName of fileNames) {
        const data = await loadTranslationFile(filePath, fileName, this.format);
        localKeys.push(...data);
      }
    } catch (error) {
      core.error(`Error reading file for locale ${this.sourceLanguage}: ${error.message}`);
    }

    return localKeys;
  }

  /**
   * Fetches all remote keys. The data is returned in the LokaliseApi PaginatedResult format.
   */
  async getRemoteKeys(): Promise<LokaliseListKeysPayload> {
    return await this.lokaliseApi.keys.list({
      project_id: this.projectId,
      filter_platforms: this.platform,
      filter_archived: 'exclude',
      limit: LOKALISE_FETCH_LIMIT,
    });
  }

  protected getLanguageFilePath(languageCode: string): string {
    return this.sourceLanguageDirectory.replace(LANG_ISO_PLACEHOLDER, languageCode);
  }
}
