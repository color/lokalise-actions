import { createReadStream, createWriteStream } from 'fs';
import { writeFile, unlink } from 'fs/promises';
import { join } from 'path';
import { pipeline } from 'stream/promises';

import * as core from '@actions/core';
import got from 'got';
import stringify from 'json-stable-stringify';
import PO from 'pofile';
import { Parse } from 'unzipper';

import { LokaliseClient } from '@src/lokalise/base/client';
import { FILE_FORMAT, LOKALISE_LANG_ISO_PLACEHOLDER, PLACEHOLDER_FORMAT_BY_FILE_FORMAT } from '@src/lokalise/constants';

const BUNDLE_DESTINATION = './translations.zip';

export class LokalisePullClient extends LokaliseClient {
  /**
   * Downloads a zip file of all translations for all languages for the given project.
   * The bundle is extracted and its files are post processed based on the file format.
   */
  async pull(): Promise<void> {
    const [baseDirectory, ISOCodeSubPath] = this.translationDirectory.split(LOKALISE_LANG_ISO_PLACEHOLDER);
    const directoryPrefix = join(LOKALISE_LANG_ISO_PLACEHOLDER, ISOCodeSubPath);

    const format = this.format === FILE_FORMAT.JSON ? 'json_structured' : this.format;
    const replaceBreaks = this.format === FILE_FORMAT.JSON ? false : true;
    try {
      const { bundle_url } = await this.lokaliseApi.files.download(this.projectId, {
        format,
        original_filenames: true,
        directory_prefix: directoryPrefix,
        replace_breaks: replaceBreaks,
        include_comments: true,
        include_description: true,
        placeholder_format: PLACEHOLDER_FORMAT_BY_FILE_FORMAT[this.format],
        json_unescaped_slashes: true,
      });
      core.info('Created download bundle');

      await this.downloadBundle(bundle_url);
      await this.extractBundleToTranslationDirectory(baseDirectory);
    } catch (error) {
      core.setFailed(error.message);
    }
  }

  private async downloadBundle(bundleUrl: string): Promise<void> {
    await pipeline(got.stream(bundleUrl), createWriteStream(BUNDLE_DESTINATION));
  }

  private async extractBundleToTranslationDirectory(baseDirectory: string): Promise<void> {
    const zip = createReadStream(BUNDLE_DESTINATION).pipe(Parse({ forceStream: true }));
    for await (const entry of zip) {
      const { path, type } = entry;
      if (type === 'File') {
        const content = (await entry.buffer()).toString('utf-8');
        const fullPath = join(baseDirectory, path);
        await writeFile(fullPath, postProcessContent(content, this.format));
        core.info(`Imported ${path}`);
      } else {
        entry.autodrain();
      }
    }

    await unlink(BUNDLE_DESTINATION);
  }
}

/**
 * Lokalise's exported files are not 1:1 with the imports will cause lots of noise in git diffs.
 * - PO file export is limited by what they parse: https://docs.lokalise.com/en/articles/1400767-gettext-po-pot
 * - Structured JSON has spacing and sorting issues.
 *
 * To minimize the resulting diff, post process the downloaded translations files.
 */
function postProcessContent(content: string, format: string): string {
  switch (format) {
    case FILE_FORMAT.PO:
      return formatPO(content);
    case FILE_FORMAT.JSON:
      return formatStructuredJson(content);
    default:
      core.error('Unsupported file format');
      return '';
  }
}

/**
 * Lokalise has limitations to their PO file support that we must workaround:
 *
 * 1. Make sorting case sensitive (there's a separate sorting bug as well)
 * 2. Flag messages where msgids contains '%' as 'python-format'
 * 3. Treat the extractedComments (#.) as just comments (#).
 * 4. Remove plural-forms header property if it is empty.
 *
 * These adjustments make the output PO files nearly identical, format-wise,
 * with the PO files generated by Django's makemessages.
 */
function formatPO(content: string): string {
  const parsed = PO.parse(content);
  // sort alphabetically by msgid
  parsed.items.sort((a, b) => (a.msgid < b.msgid ? -1 : a.msgid > b.msgid ? 1 : 0));

  if (parsed.headers['Plural-Forms'] === '') {
    delete parsed.headers['Plural-Forms'];
  }

  for (const item of parsed.items) {
    item.comments = item.extractedComments;
    item.extractedComments = [];
    if (item.msgid.includes('%')) {
      item.flags['python-format'] = true;
    }
  }

  return parsed.toString();
}

/**
 * TODO: Lokalise fixes their sort + spacing bug use the same stringify package as FormatJS
 * json-stable-stringify provides consistent key sorting and formatting
 */
function formatStructuredJson(content: string): string {
  const parsed = JSON.parse(content);
  for (const key in parsed) {
    const description = parsed[key]['notes'];
    if (description === '') {
      delete parsed[key]['notes'];
    }
  }
  return stringify(parsed, { space: 2 });
}
